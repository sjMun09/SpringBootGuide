많은 개발자들이 어떻게 하면 테스트 코드를 더 잘 작성하고 활용할 수 있는지를 고민하고 있으며, 
그 결과로 애자일 방법론 중 하나인 테스트 주도 개발 TDD(Test-Driven-Development)도 등장했습니다.
사실 테스트 코드를 작성하는 것과 테스트 주도 개발은 엄연히 다릅니다.

하지만 TDD은 개발 관점을 다르게 볼 수 있는 기회가 될 수 있으므로 이 책에서도 간단히 언급하고 넘어가겠습니다.

→ 이 말을 하셨는데, 난 어떻게 해야하는 것일까?
→ 어떤 것을 공부하라는 취지로 이런 문구를 남겨 놓으신 것일까 ?

## Test code를 작성하는 이유 ?

- 개발 과정에서 문제를 미리 발견할 수 있습니다. (가장 큰 이유)
- 리팩토링의 리스크가 줄어듭니다.
- app을 가동해서 직접 테스트하는 것보다 테스트를 빠르게 진행할 수 있습니다.
- 하나의 명세 문서로서의 기능을 수행합니다.
- 몇 가지 프레임워크에 맞춰 Test Code를 작성하면 좋은 코드를 생산할 수 있습니다.
- 코드가 작성된 목적을 명확하게 표현할 수 있으며, 불필요한 내용이 추가되는 것을 방지합니다.

> 모든 개발자에게 테스트 코드란 꼭 해야하는 마감기한이 정해진 과제 같은 것이라고 나는 감히 생각한다.
그만큼 테스트 코드 및 TDD에 대해 중요하게 생각하기 때문이다.
이에 나는 스프링부트 백엔드 개발자로써 TestCode와 TDD를 더욱 잘 알기 위해
무엇을 어떻게 공부해야 하는 것일까?
> 

Test Code를 먼저 작성하고 비즈니스 로직을 먼저 작성하든, 테스트 코드를 먼저 작성하든 테스트 코드를 작성하고 테스트하는 것은 코드에 잠재된 문제를 발견하는 데 엄청 큰 도움이 됩니다.

## 단위 테스트와 통합 테스트

테스트 방법은 여러 기준으로 분류할 수 있습니다. 
그중 테스트 대상 범위를 기준으로 구분하면 크게 **단위 테스트**(Unit Test)와 **통합 테스트**(Integration Test)로 구분됩니다.

- 단위 테스트 : app의 개별 모듈을 독립적으로 테스트
- 통합 테스트 : app을 구성하는 다양한 모듈을 결합해 전체적인 로직이 의도한 대로 동작하는지 테스트

IMG

### 단위 테스트의 특징

테스트 대상의 범위를 기준으로 가장 작은 단위의 테스트 방식이다.
일반적으로 메서드 단위로 테스트를 수행하게 되며, 메서드 호출을 통해 의도한 결괏값이 나오는지 확인하는 수준으로 테스트를 진행하게 됩니다.
즉, 특정 모듈에 대한 테스트만 진행한다고 보시면 됩니다.
(MSA도 작은 모듈로 쪼개서 하는 것인데 이 와 연관이 있는..? 이러한 것들 때문에 MSA라는 개념이 등장한건가? ㅋㅋ)
또한 단위 테스트는 테스트 비용이 적게 들기 때문에 테스트 피드백을 빠르게 받을 수 있습니다.

> 해당 챕터를 읽으면서, 단위테스트의 중요성을 깨달았으며, 잘 작성된 단위테스트란 무엇일까?
단위테스트는 어떻게 해야 잘 작성할 수 있을까? 를 공부하는게 저의 숙제인 것 같습니다.
현 시점에서 스프링부트에선 단위테스트 JUnit5를 지원하고 있습니다.
따라서 JUnit5에 대해서 좀더 공부할 필요가 있다고 생각합니다.
어떻게 더 잘 작성할 수 있을까 ?
> 

<aside>
📌 Test Cost
테스트 비용이란 용어는 소프트웨어 공학에서 많이 사용됩니다.
여기서 말하는 비용은 금전적인 비용을 포함해서 시간, 인력과 같은 개발에 필요한 것들을 포괄합니다.
통계적으로 하나의 서비스를 개발할 때는 개발 과정에서 60%, 테스트 과정에서 40%의 비용이 듭니다.

</aside>

# Test Code 작성하는 방법

## Given - When - Then 패턴

인프런의 유명한 강사이신 김영한님도 해당 패턴을 주로 사용하십니다.
테스트 코드를 표현하는 방식 중 하나입니다.
단어에서 유추할 수 있듯이 다음과 같은 단계를 설정해서 각 단계의 목적에 맞게 코드를 작성합니다.

### Given

테스트를 수행하기 전에 테스트에 필요한 환경을 설정하는 단계.
테스트에 필요한 변수를 정의하거나 Mock 객체를 통해 특정 상황에 대한 행동을 정의한다.

### When

테스트의 목적을 보여주는 단계이다.
실제 테스트 코드가 포함되며, 테스트를 통한 결괏값을 가져온다.

### Then

테스트의 결과를 검증하는 단계이다.
일반적으로 When 단계에서 나온 결괏값을 검증하는 작업을 수행한다.
결괏값이 아니더라도 이 테스트를 통해 나온 결과에서 검증해야 하는 부분이 있다며 이 단계에 포함한다.

> 잠깐, 여기서 질문, Mock 객체란 무엇일까? Mock 란 무엇일까? → 답을 명확하게 말하지 못한다면 공부를 제대로 한 것이 아니다. Mock에 대해 다시 공부하자 
여기서 하나 더 짚고 넘어가야할 것이 있다.
이전에 프로젝트를 같이하신 박상민님께서 알려주신 테스트 코드 잘 작성하는 법을 살펴보고 오는 것을 권장한다.
살펴보고 어떻게 공부하면 좋을지 나만의 순서를 정해두자. 
그 후, 시간을 짜내어 공부해보자.
> 

Given-When-Then 패턴은 TDD개발에서 파생된 BDD(행위 주도 개발)를 통해 탄생한 테스트 접근 방식입니다.
일반적으로 단위 테스트보다는 비교적 많은 환경을 포함해서 테스트하는 인수 테스트에서 사용하는 것이 적합하다고 알려져 있지만, 개인적으로는 단위 테스트에서도 유용하게 활용할 수 있다고 생각합니다.

## 좋은 테스트를 작성하는 5가지 속성 F I R S T

### 빠르게 Fast

테스트는 빠르게 수행돼야 한다.
테스트가 느리면 코드를 개선하는 작업이 느려져 코드 품질이 떨어질 수 있기 떄문입니다.
테스트 속도에 절대적인 기준은 없지만 목적을 단순하게 설정해서 작성하거나 외부 환경을 사용하지 않는 단위 테스트를 작성하는 것 등을 빠른 테스트라고 할 수 있습니다.

### 고립된, 독립적인 Isolated

하나의 테스트 코드는 목적으로 여기는 하나의 대상에 대해서만 수행돼야 합니다.
만약 하나의 테스트가 다른 테스트 코드와 상호작용하거나 관리할 수 없는 외부 소스를 사용하게 되면 외부 요인으로 인해 테스트가 수행되지 않을 수 있습니다.

### 반복 가능한 repeatable

테스트는 어떤 환경에서도 반복 가능하도록 작성해야 합니다.
이 의미는 앞의 Isolated 규칙과 비슷한 의미를 갖고 있습니다. 
테스트는 개발 환경의 변화나 네트워크의 연결 여부와 상관없이 수행돼야 합니다.

### 자가 검증 Self-Validating

테스트는 그 자체만으로도 테스트의 검증이 완료돼야 합니다.
테스트가 성공했는지 실패했는지 확인할 수 있는 코드를 함께 작성해야 합니다.
만약 결괏값과 기댓값을 비교하는 작업을 코드가 아니라 개발자가 직접 확인하고 있다면 좋지 못한 코드입니다.

### 적시에 Timely

테스트 코드는 테스트하려는 app code를 구현하기 전에 완성돼야 합니다.
너무 늦게 작성된 테스트 코드는 정상적인 역할을 수행하기 어려울 수 있습니다. 
또한 테스트 코드로 인해 발견된 문제를 해결하기 위해 소모되는 개발 비용도 커지기 쉽습니다.
다만 이 개념은 테스트 주도 개발의 원칙을 따르는 테스트 작성 규칙으로, 테스트 주도 개발을 기반으로 애플리케이션을 개발하는 것이 아니라면 이 규칙은 제외하고 진행하기도 합니다.

# JUnit

JUnit의 가장 큰 특징은 어노테이션 기반의 테스트 방식을 지원한다는 것이다.
즉, JUnit을 사용하면 몇 개의 어노테이션만으로 간편하게 Test code를 작성할 수 있습니다.
또한 JUnit을 활용하면 단정문(assert)을 통해 테스트 케이스의 기댓값이 정상적으로 도출됐는지 검토할 수 있다는 장점이 있습니다.

(166~169 페이지 코드를 ch06의 코드와 비교하면서 공부)

### JUnit 생명주기

생명주기와 관련되어 테스트 순서에 관여하게 되는 대표적인 어노테이션

- `@Test` : 테스트 코드를 포함한 메서드를 정의
- `@BeforeAll` : 테스트를 시작하기 전에 호출되는 메서드를 정의
- `@BeforeEach` : 각 테스트 메서드가 실행되기 전에 동작하는 메서드를 정의
- `@AfterAll` : 테스트를 종료하면서 호출되는 메서드를 정의
- `@AfterEach` : 각 테스트 메서드가 종료되면서 호출되는 메서드를 정의

`@BeforeAll` 과 `@AfterAll` 어노테이션이 지정된 메서드는 전체 테스트 동작에서 처음과 마지막에만 각각 수행됩니다.
`@BeforeEach`와 `@AfterEach` 어노테이션이 지정된 메서드는 각 테스트가 실행될 때 `@Test` 어노테이션이 지정된 테스트 메서드를 기준으로 실행되는 것을 볼 수 있습니다.

> 컨트롤러는 클라이언트로부터 요청을 받아 요청에 걸맞은 서비스 컴포넌트로 요청을 전달하고 그 결괏값을 가공해서 클라이언트에게 응답하는 역할을 수행합니다.
즉, 애플리케이션을 구성하는 여러 레이어 중 가장 웹에 가까이에 있는 모듈이라고 볼 수 있습니다.
> 

독립적인 테스트 코드를 작성하기 위해서는 Mock 객체를 활용해야 한다.

- getProduct() 메서드에 대한 테스트

```java
@WebMvcTest(ProductController.class)
class ProductControllerTest {

    @Autowired
    private MockMvc mockMvc;

    // ProductController에서 잡고 있는 Bean 객체에 대해 Mock 형태의 객체를 생성해줌
    @MockBean
    ProductServiceImpl productService;

    // 예제 7.6
    // http://localhost:8080/api/v1/product-api/product/{productId}
    @Test
    @DisplayName("MockMvc를 통한 Product 데이터 가져오기 테스트")
    void getProductTest() throws Exception {

        // given : Mock 객체가 특정 상황에서 해야하는 행위를 정의하는 메소드
        given(productService.getProduct(123L)).willReturn(
            new ProductResponseDto(123L, "pen", 5000, 2000));

        String productId = "123";

        // andExpect : 기대하는 값이 나왔는지 체크해볼 수 있는 메소드
        mockMvc.perform(
                get("/product?number=" + productId))
            .andExpect(status().isOk())
            .andExpect(jsonPath(
                "$.number").exists()) // json path의 depth가 깊어지면 .을 추가하여 탐색할 수 있음 (ex : $.productId.productIdName)
            .andExpect(jsonPath("$.name").exists())
            .andExpect(jsonPath("$.price").exists())
            .andExpect(jsonPath("$.stock").exists())
            .andDo(print());

        // verify : 해당 객체의 메소드가 실행되었는지 체크해줌
        verify(productService).getProduct(123L);
    }
}
```

### @WebMvcTest(테스트 대상 클래스.class)

웹에서 사용되는 요청과 응답에 대한 테스트를 수행할 수 있습니다.
대상 클래스만 로드해 테스트를 수행하며, 만약 대상 클래스를 추가하지 않으면 @Controller, @RestController, @ControllerAdvice 등의 컨트롤러 관련 빈 객체가 모두 로드됩니다.
@SpringBootTest보다 가볍게 테스트하기 위해 사용됩니다.

### @MockBean

@MockBean은 실제 빈 객체가 아닌 Mock(가짜) 객체를 생성해서 주입하는 역할을 수행합니다.
@MockBean이 선언된 객체는 실제 객체가 아니기 때문에 실제 해위를 수행하지 않습니다.
그렇기 때문에 해당 객체는 개발자가 Mockito의 given() 메서드를 통해 동작을 정의해야 합니다.

### @Test

테스트 코드가 포함돼 잇다고 선언하는 어노테이션이다.
JUnit, Jupiter에서는 이 어노테이션을 감지해서 테스트 계획에 포함시킵니다.

### @DisplayName

테스트 메서드의 이름이 복잡해서 가독성이 떨어질 경우 이 어노테이션을 통해 테스트에 대한 표현을 정의할 수 있습니다.

일반적으로 @WebMvcTest 어노테이션을 사용한 테스트는 슬라이스(slice) 테스트라고 부른다.
슬라이스 테스트는 단위 테스트와 통합 테스트의 중간 개념으로 이해하면 되는데, 
레이어드 아키텍처를 기준으로 각 레이어별로 나누어 테스트를 진행한다는 것을 의미합니다.

단위 테스트를 수행하기 위해서는 모든 외부 요인을 차단하고 테스트를 진행해야 하지만 컨트롤러는 개념상 웹과 맞닿은 레이어로서 외부 요인을 차단하고 테스트하면 의미가 없기 때문에 슬라이스 테스트를 진행하는 경우가 많습니다.

위 예제 코드를 보면 @MockBean 어노테이션을 통해 ProductController가 의존성을 가지고 있던 ProductService 객체에 Mock 객체를 주입했습니다.
Mock 객체에는 테스트 과정에서 맡은 동작을 정의해야 합니다.

```java
  // given : Mock 객체가 특정 상황에서 해야하는 행위를 정의하는 메소드
        given(productService.getProduct(123L)).willReturn(
            new ProductResponseDto(123L, "pen", 5000, 2000));
```

또한, Mockito에서 제공하는 given() 메서드를 통해 이 객체에서 어떤 메서드가 호출되고 어떤 파라미터를 주입받는지 가정한 후 willReturn() 메서드를 통해 어떤 결과를 리턴할 것인지 정의하는 구조로 코드를 작성합니다.
메서드 이름에서 알 수 있듯이 이부분의 코드가 앞에서 설명한 Given에 해당 됩니다.

```java
    @Autowired
    private MockMvc mockMvc;
```

MockMvc는 컨트롤러의 API를 테스트하기 위해 사용된 객체입니다.
정확하게는 서블릿 컨테이너의 구동 없이 가상의 MVC 환경에서 모의 HTTP 서블릿을 요청하는 유틸리티 클래스입니다.

```java
 // andExpect : 기대하는 값이 나왔는지 체크해볼 수 있는 메소드
        mockMvc.perform(
                get("/product?number=" + productId))
            .andExpect(status().isOk())
            .andExpect(jsonPath(
                "$.number").exists()) // json path의 depth가 깊어지면 .을 추가하여 탐색할 수 있음 (ex : $.productId.productIdName)
            .andExpect(jsonPath("$.name").exists())
            .andExpect(jsonPath("$.price").exists())
            .andExpect(jsonPath("$.stock").exists())
            .andDo(print());
```

이 객체의 전반적인 사용법을 보여주는 테스트 코드입니다.

perform() 메서드를 이용하면 서버로 URL 요청을 보내는 것처럼 통신 테스트 코드를 작성해서 컨트롤러를 테스트할 수 있습니다.
perform() 메서드는 MockMvcRequestBuilders에서 제공하는 HTTP 메서드로 URL을 정의해서 사용합니다.
MockMvcRequestBuilder는 GET, POST, PUT, DELETE에 매핑되는 메서드를 제공합니다.
이 메서드는 MockHttpServletRequestBuilder 객체를 리턴하며, HTTP 요청 정보를 설정할 수 있게 됩니다.

그리고 perform() 메서드의 결괏값으로 ResultActions 객체가 리턴되는데, andExpect() 메서드를 사용해 결괏값 검증을 수행할 수 있습니다. andExpect() 메서드에서는 ResultMatcher를 활용하는데, 이를 위해 MockMvcResultMatchers 클래스에 정의돼 있는 메서드를 활용해 생성할 수 있습니다.

요청과 응답의 전체 내용을 확인하려면 45번 줄과 같이 andDo() 메서드를 사용합니다.
MockMvc의 코드는 모두 합쳐져 있어 구분하기는 애매하지만 전체적인 ‘When-Then’의 구조를 갖추고 있음을 확인할 수 있습니다.

마지막으로 verify() 메서드는 지정된 메서드가 실행됐는지 검증하는 역할입니다. 
(일반적으로 given()에 정의된 동작과 대응합니다)

(이후엔 183 service 객체의 테스트, 189 리포지토리 객체의 테스트, Jacoco를 활용한 테스트에 대해 나오긴 합니다. → 정리를 생략하였으나 필요하면 읽으면 될 것 같습니다.)

# TDD 테스트 주도 개발

반복 테스트를 이용한 sw 개발 방법론으로서 테스트 코드를 먼저 작성한 후 테스트를 통과하는 코드를 작성하는 과정을 반복하는 sw 개발 방식입니다.
애자일 방법론 중 하나인 익스트림 프로그래밍의 Test-First 개념에 기반을 둔, 개발 주기가 짧은 개발 프로세스로 단순한 설계를 중시합니다.

<aside>
📌 애자일 sw 개발 방법론이란?
애자일은 신속한 반복 작업을 통해 실제 작동 가능한 sw를 개발하는 개발 방식입니다.
원래 애자일 방법론 자체는 일하는 방법에 대한 관점으로 sw 개발에만 국한되지는 않습니다.

애자일 sw 개발 방법론의 핵심은 신속한 개발 프로세스를 통해 수시로 변하는 고객의 요구사항에 대응해서 제공하는 서비스의 가치를 극대화하는 것입니다.

</aside>

## TDD 개발 주기

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/54e16321-5804-45d8-b4b4-28cc6c9bf0f4/Untitled.png)

- 실패 테스트 작성 : 실패하는 경우의 테스트 코드를 먼저 작성한다.
- 테스트를 통과하는 코드 작성 : 테스트 코드를 성공시키기 위한 실제 코드를 작성한다.
- 리팩토링 : 중복 코드를 제거하거나 일반화하는 리팩토링을 수행한다.

일반적인 개발 방법은 (설계 → 설계에 맞게 구현 → 마지막에 테스트 코드 작성) 이렇게 흘러갑니다.
그러나 TDD에선 설계 이후 바로 Test Code를 작성하고, app code를 작성한다는 점에서 차이가 있습니다.

## TDD의 효과

### 디버깅 시간 단축

테스트 코드 기반으로 개발이 진행되기 때문에 문제가 발생했을 떄 어디에서 무엇이 잘못됐는지 확인하기가 쉽습니다.

### 생산성 향상

테스트 코드를 통해 지속적으로 app 코드의 불안정성에 대한 피드백을 받기 때문에 리팩토링 횟수가 좋고 생산성이 높아집니다.

### 재설계 시간 단축

작성돼 있는 테스트 코드를 기반으로 코드를 작성하기 떄문에 재설계가 필요할 경우 테스트 코드를 조정하는 것으로 재설계 시간을 단축할 수 있습니다.

### 기능 추가와 같은 추가 구현이 용이

테스트 코드를 통해 의도한 기능을 미리 설계하고 코드를 작성하기 떄문에 목적에 맞는 코드를 작성하는 데 비교적 용이합니다.
