## MSA가 나온 이유 ?

각 기능들을 하나의 모듈의 app에 통합하게 되면 서버를 업데이트 하거나 app 유지보수할 때마다
’사이트 작업중’이라는 팻말을 걸고 작업해야한다.
이렇게 서비스를 구성한다면 그만큼 개발에 보수적인 입장일 수 밖에 없고, 서비스 자체 규모도 증가하고 서비스를 구동하는데 오래 걸린다.
이를 해결하기 위해 MSA가 나오게 된 것이다.

### 그렇다면 MSA는 무엇일까?

서비스 규모를 작게 나누어 구성한 아키텍처를 뜻한다.
MSA를 적용한다면 각 기능별로 나눠서 개발하게 되는 것이다.

### 서버 간 통신

한 서버가 다른 서버에 통신을 요청하는 것을 의미한다.
서버와 클라이언트 구조다.
(몇 가지 프로토콜에 의해 다양한 통신 방식을 적용할 수 있지만 가장 많이 사용되는 방식은 HTTP/HTTPS 방식)

### 2.2

스프링 부트에서 springboot-starter-web 모듈을 사용하면 기본적으로 톰캣을 사용하는 스프링 Mvc 구조를 기반으로 동작하게 된다. (springboot 동작구조 이미지 참고하자)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/637c47c8-3f96-4a2b-ba16-3aca31413abf/Untitled.heic)

서블릿은 클라이언트의 요청을 처리하고 결과를 반환하는 자바 웹 프로그래밍 기술이다.
일반적으로 서블릿은 서블릿 컨테이너에서 관리한다.
서블릿 컨테이너는 서블릿 인스턴스를 생성하고 관리하는 역할을 수행하는 주체로서,
톰캣은 WAS의 역할과 서블릿 컨테이너의 역할을 수행하는 대표적인 컨테이너이다.

### 서블릿 컨테이너 특징

- 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 관리한다.
- 서블릿 객체는 싱글톤 패턴으로 관리된다.
- 멀티 스레딩을 지원한다.

스프링에서는 DIspatcherServlet이 서블릿의 역할을 수행한다.

일반적으로 스프링은 톰캣을 임베디드해 사용합니다.
그렇기 때문에 서블릿 컨테이너와 DispatcherServlet은 자동 설정된 web.xml의 설정값을 공유한다.

그림 2.2에 

(1) DispatcherServlet으로 요청(HttpServletRequest)이 들어오면 DispatcherServlet은 핸들러 매핑(Handler Mapping)을 통해 요청 URI에 매핑된 핸들러를 탐색합니다.

여기서 핸들러는 컨트롤러를 의미합니다.

(2) 그리고 핸들러 어댑터로 컨트롤러를 호출합니다.

(3) 핸들러 어댑터에 컨트롤러의 응답이 돌아오면 ModelAndView로 응답을 가공해 반환합니다.

(4) 뷰 형식으로 리턴하는 컨트롤러를 사용할 때는 뷰 리졸버(View Resolver)를 통해 View를 받아 리턴합니다.

핸들러 매핑은 요청 정보를 기준으로 어떤 컨트롤러를 사용할지 선정하는 인터페이스입니다.
핸들러 매핑 인터페이스는 여러 구현체를 가지며, 대표적인 구현체 클래스는 다음과 같습니다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/ff8d4958-5b9d-48b1-9b52-cb86441f17af/Untitled.heic)

뷰 리졸버는 뷰의 렌더링 역할을 담당하는 뷰 객체를 반환합니다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/e6dfbffc-2a91-4558-8a0b-cb1cddcb1385/Untitled.heic)

이 책에서 다룰 app은 뷰가 없는 REST gudtlrdml @ResponseBody를 사용할 예정이라
그림 2.4와 같이 뷰 리졸버를 호출하지 않고 MessageConverter를 거쳐 JSON 형식으로 변환해서 응답합니다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/1743f74d-c293-4def-8b0e-7955130cb336/Untitled.heic)

여기서 MessageConverter는 요청과 응답에 대해 Body 값을 변환하는 역할을 수행합니다.
스프링 부트의 자동 설정 내역을 보면 HttpMessageConverter 인터페이스를 사용하고 있는 것을 알 수 있습니다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/a155a755-208a-4688-b8d7-f3120bed3060/Untitled.png)

02 줄을 보면 HttpMessageConverter 인터페이스를 빈으로 등록하는 것을 확인할 수 있습니다.
해당 인터페이스를 기반으로 하는 구현체 클래스는 다양하며, Content-Type을 참고해서 Converter를 선정한다. 그러나 스프링 부트에서는 자동 설정되기 때문에 별도 설정이 필요하지 않습니다.

> 스프링 부트는 여러 자동 설정을 지원하기 때문에 app을 아주 편리하게 개발 가능합니다.
But, 심도 있는 개발을 위해서는 스프링의 동작원리를 꼭꼭꼭!!! 이해해야 합니다.
스프링 모듈만으로 개발을 진행해보면 동작 원리를 파악하는 데 큰 도움이 됩니다.
> 

## 2.3 레이어드 아키텍처

레이어드 아키텍처란 app의 컴포넌트를 유사 관심사를 기준으로 레이어로 묶어 수평적으로 구성한 구조를 의미합니다. 레이어드 아키텍처는 여러 방면에서 쓰이는 개념이며, 어떻게 설계하느냐에 따라 용어와 계층의 수가 달라집니다.

일반적으로 레이어드 아키텍처라 하면 3계층 또는 4계층 구성을 의미합니다.
이 차이는 인프라(데이터베이스) 레이어의 추가 여부로 결정됩니다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/05f6aa4c-fdb6-4471-b691-eaf760e0db0e/Untitled.heic)

각 계층은 다음과 같이 구분됩니다.

1. 프레젠테이션 계층
- 애플리케이션의 최상단 계층, 클라이언트의 요청을 해석하고 응답하는 역할
- UI나 API 제공
- 프레젠테이션 계층은 별도의 비즈니스 로직을 포함하고 있지 않으므로 비즈니스 계층으로 요청을 위임하고 받은 결과를 응답하는 역할만 수행합니다.
2. 비즈니스 계층
- 애플리케이션이 제공하는 기능을 정의하고 세부 작업을 수행하는 도메인 객체를 통해 업무를 위임하는 역할을 수행합니다.
- DDD 기반의 아키텍처에서는 비즈니스 로직에 도메인이 포함되기도 하고, 별도로 도메인 계층을 두기도 합니다.
3. 데이터 접근 계층
- 데이터베이스에 접근하는 일련의 작업을 수행합니다.

레이어드 아키텍처는 하나의 애플리케이션에도 적용되지만 애플리케이션 간의 관계를 설명하는 데도 사용할 수 있습니다. 

### 레이어드 아키텍처 기반 설계 특징

- 각 레이어는 가장 가까운 하위 레이어의 의존성을 주입받는다.
- 각 레이어는 관심사에 따라 묶여 있으며, 다른 레이어의 역할을 침범하지 않는다.
    - 각 컴포넌트의 역할이 명확하므로 코드의 가독성과 기능 구현에 유리하다.
    - 코드의 학장성도 좋아진다.
- 각 레이어가 독립적으로 작성되면 다른 레이어와의 의존성을 낮춰 단위 테스트에 용이하다.

이 책은 스프링과 관련된 레이어드 아키텍처에 초점을 맞춰서 쓰였으며, 스프링 부트는 별도의 설정 없이 spring-boot-starter-web의 dependency를 사용할 때는 기본적으로 스프링 MVC 구조를 띠게 되며, 대체로 아래 그림 2.6과 같은 레이어드 아키텍처를 이루게 됩니다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/4381add2-11dd-4d85-b0d6-508e0d89ec0f/Untitled.heic)

그림 2.6은 그림 2.5의 레이어드 아키텍처를 스프링에 적용한 모습입니다.

Spring MVC는 model-view-controller의 구조로 view와 controller는 프레젠테이션 계층 영역이며, Model은 비즈니스와 데이터 접근 계층의 영역으로 구분할 수 있습니다.
다만 스프링 MVC 모델로 레이어드 아키텍처를 구현하기 위해서는 역할을 세분화합니다. 비즈니스 계층에 서비스를 배치해 엔티티와 같은 도메인 객체의 비즈니스 로직을 조합하돌고 하고 데이터 접근 계층에는 DAO(Spring Data JPA 에서는 Repository)를 배치해 도메인을 관리합니다.

스프링 레이어드 아키텍처는 다음과 같이 설명할 수 있습니다.
(대체로 역할은 동일함)

### 프레젠테이션 계층

- 상황에 따라 UI(User Interface)계층이라고도 한다
- 클라이언트와의 접점이 된다.
- 클라이언트로부터 데이터와 함께 요청을 받고 처리 결과를 응답으로 전달하는 역할이다.

### 비즈니스 계층

- 상황에 따라 서비스(Service) 계층이라고도 한다.
- 핵심 비즈니스 로직을 구현하는 영역이다.
- 트랜잭션 처리나 유효성 검사 등의 작업도 수행한다.

### 데이터 접근 계층

- 상황에 따라 영속 계층이라고도 한다.
- 데이터베이스에 접근해야 하는 작업을 수행한다.
- 그림 2.6에서는 DAO라는 컴포넌트를 표현했지만 Spring Data JPA에서는 DAO 역할을 리포지토리가 수행하기 때문에 리포지토리로 대체할 수 있습니다.

## 2.4 디자인 패턴

디자인 패턴은 sw를 설계할 때 자주 발생하는 문제들을 해결하기 위해 고안된 해결책이다.
디자인 패턴에서 ‘패턴’이라는 단어는 app 개발에서 발생하는 문제는 유사한 경우가 많고 해결책도 동일하게 적용할 수 있다는 의미를 내포합니다. 그러나 디자인 패턴이 모든 문제의 정답은 아니며, 상황에 맞는 최적 패턴을 결정해서 사용하는 것이 바람직합니다.

### 2.4.1 디자인 패턴의 종류

디자인 패턴을 구체화해서 정리한 대표적인 분류 방식으로 ‘GoF 디자인 패턴’이라는 것이 있습니다.
여기서 GoF는 ‘Gang of Four’의 줄임말로, 디자인 패턴을 구체화하고 체계화해서 분류한 4명의 인물을 의미합니다. GoF의 디자인 패턴 분류는 아래 표와 같습니다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/fdaf001a-03df-4a8f-91a5-842f7032b401/Untitled.heic)

GoF 디자인 패턴은 생성 패턴, 구조 패턴, 행위 패턴의 총 세 가지로 구분됩니다.

### 생성 패턴

- 객체 생성에 사용되는 패턴으로, 객체를 수정해도 호출부가 영향을 받지 않게 합니다.

### 구조 해턴

- 객체를 조합해서 더 큰 구조를 만드는 패턴입니다.

### 행위 패턴

- 객체 간의 알고리즘이나 책임 분배에 관한 패턴입니다.
- 객체 하나로는 수행할 수 없는 작업을 여러 객체를 이용해 작업을 분배합니다.
결합도 최소화를 고려할 필요가 있습니다.

### 2.4.2 생성 패턴

- **추상 팩토리** : 구체적인 클래스를 지정하지 않고 상황에 맞는 객체를 생성하기 위한 인터페이스를 제공하는 패턴입니다.
- **빌더** : 객체의 생성과 표현을 분리해 객체를 생성하는 패턴입니다.
- **팩토리 메서드** : 객체 생성을 서브클래스로 분리해서 위임하는 패턴입니다.
- **프로토타입** : 원본 객체를 복사해 객체를 생성하는 패턴입니다.
- **싱글톤** : 한 클래스마다 인스턴스를 하나만 생성해서 인스턴스가 하낭미을 보장하고 어느 곳에서도 접근할 수 있게 제공하는 패턴입니다.

### 2.4.3 구조 패턴

- 어댑터 : 클래스의 인터페이스를 의도하는 인터페이스로 변환하는 패턴입니다.
- 브리지 : 추상화 구현을 분리해서 각각 독립적으로 변형케 하는 패턴입니다.
- 컴포지트 : 여러 객체로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루는 패턴입니다.
- 데코레이터 : 객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 하는 패턴
- 퍼시드 : 서브시스템의 인터페이스 집합들에 하나의 통합된 인터페이스를 제공하는 패턴
- 플라이웨이트 : 특정 클래스의 인스턴스 한 개를 가자ㅣ고 여러 개의 ‘가상 인스턴스’를 제공할 때 상요하는 패턴입니다.

### 2.4.4 행위 패턴

- 책임 연쇄 : 요청 처리 객체를 집합으로 만들어 결합을 느슨하게 만드는 패턴입니다.
- 커맨드 : 실행될 기능을 캡슐화해서 주어진 여러 기능을 실행하도록 클래스를 설계하는 패턴입니다.
- 인터프리터 : 주어진 언어의 문법을 위한 표현 수단을 정의하고 해당 언어로 구성된 문장을 해석하는 패턴
- 이터레이터 : 내부 구조를 노출하지 않으면서 해당 객체의 집합 원소에 순차적으로 접근하는 방법을 제공하는 패턴
- 미디에이터 : 한 집합에 속한 객체들의 상호작용을 캡슐화하는 객체를 정의한 패턴
- 메멘토 : 객체의 상태 정보를 저장하고 필요에 따라 상태를 복원하는 패ㅓㄴ
- 옵저버 : 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버 목록을 객체에 등록해 상태가 변할 때마다 메서드 등을 통해 객체가 직접 옵저버에게 통지하게 하는 디자인 패턴
- 스테이트 : 상태에 따라 객체가 행동을 변경하게 하는 패턴
- 스트래티지 : 행동을 클래스로 캡슐화해서 동적으로 행동을 바꿀 수 있게 하는 패턴
- 템플릿 메서드 : 일정 작업을 처리하는 부분을 서브클래스로 캡슐화해서 전체 수행 구조는 바꾸지 않으면서 특정 단계만 변경해서 수행하는 패턴
- 비지터 : 실제 로직을 가지고 있는 객체가 로직을 적용할 객체를 방문하며 실행하는 패턴

> 사실 디자인 패턴은 우리가 자주 사용하는 라이브러리에 생각보다 엄청 많이 쓰이니 꼭 알아두길 권장합니다.
> 

## REST API

대중적으로 가장 많이 사용되는 app 인터페이스이다.
이 인터페이스를 통해 클라이언트는 서버에 접근하고 자원을 조작할 수 있다.

### REST 란 ?

월드 와이드 웹 (WWW)과 같은 분산하이퍼미디어 시스템 아키텍처의 한 형식이다.
주고 받는 자원에 이름을 규정하고 URI에 명시해 HTTP 메서드(GET, POST, PUT, DELETE)를 통해 해당 자원의 상태를 주고 받는 것을 의미한다.

### REST API란 ?

API는 app Programming Interface의 약자이며, app에서 제공하는 인터페이스를 의미한다.
API를 통해 서버 또는 프로그램 사이를 연결할 수 있습니다.

즉, REST API는 REST 아키텍처를 따르는 시스템/app 인터페이스라고 볼 수 있다.

REST 아키텍처를 구현하는 웹 서비스를 ‘RESTful하다’라고 표현한다.

## 2.5.3 REST의 특징

### 유니폼 인터페이스

일관된 인터페이스를 의미한다.
즉, REST 서버는 HTTP 표준 전송 규약을 따르기 때문에 어떤 프로그래밍 언어로 만들어졌느냐와 상관없이 플랫폼 및 기술에 종속되지 않고 타 언어, 플랫폼, 기술 등과 호환해 사용할 수 있다는 것을 의밓나다.

### **무상태성**

stateless 특징을 가진다.

무상태성이란 서버에 상태 정보를 따로 보관하거나 관리하지 않는다는 의미이다.
서버는 클라이언트가 보낸 요청에 대해 세션이나 쿠키 정보를 별도 보관하지 않는다.
그렇기 때문에 한 클라이언트가 여러 요청을 보내든 여러 클라이언트가 각각 하나의 요청을 보내든 개별적으로 처리한다. 이렇게 구성된 서비스는 서버가 불필요한 정보를 관리하지 않으므로 비즈니스 로직의 자유도가 높고 설계가 단순하다.

### 캐시 가능성

REST는 HTTP 표준을 그대로 사용하므로 HTTP의 캐싱 기능을 적용할 수 있습니다.
이 기능을 이용하기 위해서는 응답과 요청이 모두 캐싱 가능한지(Cacheable) 명시가 필요하며,
캐싱이 가능한 경우 클라이언트에서 캐시에 저장해두고 같은 요청에 대해서는 해당 데이터를 가져다 사용합니다.
이 기능을 사용하면 서버의 트랜잭션 부하가 줄어 효율적이며 사용자 입장에서 성능이 개선됩니다.

### 레이어 시스템

REST 서버는 네트워크 상의 여러 계층으로 구성될 수 있습니다.
그러나 서버의 복잡도와 관계없이 클라이언트는 서버와 연결되는 포인트만 알면 됩니다.

### 클라이언트-서버 아키텍처

REST 서버는 API를 제공하고 클라이언트는 사용자 정보를 관리하는 구조로 분리해 설계합니다.
이 구성은 서로에 대한 의존성을 낮추는 기능을 한다.

## 2.5.4 REST의 URI 설계 규칙

### URL 규칙

**URI의 마지막에는 ‘/’를 포함하지 않는다.**

- 옳은 예) http://localhost.com/product
- 잘못된 예) http://localhost.com/product

**언더바(_)는 사용하지 않고. 대신 하이폰(-)을 이용한다.**

- 하이폰은 리소스의 이름이 길어지면 사용한다.
- 옳은 예) http://localhost.com/provier-company-name
- 잘못된 예) http://localhost.com/provier_company_name

**URL에는 행위(동사)가 아닌 결과(명사)를 포함한다.**

- 옳은 예) http://localhost.com/product/123
- 잘못된 예) http://localhost.com/delete-product/123
- 행위는 HTTP 메서드로 표현할 수 있어야 한다.

**URI는 소문자로 작성해야 한다.**

- URI 리소스 경로에는 대문자 사용을 피하는 것이 좋다.
- 일부 웹 서버의 os는 리소스 경로 부분의 대소문자를 다른 문자로 인식하기 떄문이다.
이러한 이유로 RFC 3986은 URI 문법 형식을 정의하고 있는데, 호스트의 구성요소를 제외하고 URI의 대소문자를 구분해서 정의하고 있다.

**파일의 확장자는 URI에 포함하지 않는다.**

- HTTP에서 제공하는 Accept 헤더를 사용하는 것이 좋다.
